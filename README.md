# Triangulations of manifolds like the octonionic projective plane

**Alexander A. Gaifullin**

This repository contains C++ programs implementing algorithms for the paper 

Alexander A. Gaifullin, "634 vertex-transitive and more than $10^{103}$ non-vertex-transitive 27-vertex triangulations of manifolds like the octonionic projective plane", arXiv???

which is further referred to as [G].

This README file contains only technical information on the realizations of the algorithms. For the aims and descriptions of the algorithms, and also for mathematical terminology used below, see the quoted paper [G].

## General information

Each directory, except for the directory **common**, contains a separate program. Below is the list of all these programs with their short descriptions. The directory **common** contains two libraries which are used by all the programs. Namely, **myiofunctions.cpp / myiofunctions.hpp** contain input/output functions and **permutation.cpp / permutation.hpp** contain the class **Permutation**, which allows working with elements of permutation groups. The description of these libraries is given below.

**List of programs:**

1. **find**:<br/> 
   Finds all weak pseudo-manifolds $K$ with the prescribed vertex set $V$, dimension $d$, and symmetry group $G$ that have at least $N$ maximal simplices and do not contain a pair of simplices $\sigma$ and $\tau$ such that $\sigma\cup\tau$ is the whole vertex set $V$. Implements the algorithm described in Section 4 of [G].
2. **check**: <br/> 
Checks that the given $G$-invariant simplicial complex $K$ is a combinatorial manifold. (A positive answer guarantees that $K$ is a combinatorial manifold but a negative answer does not guarantee that $K$ is not.) Implements the algorithm described in Section 5 of [G].
3. **permute**: <br/>
 This program, for a given $G$-invariant simplicial complex $K$ and an element $h$ in the normalizer of $G$, produces the $G$-invariant simplicial complex $h(K)$. This simple script was conveniently used to decompose the list of 24 combinatorial manifolds from Theorem 2.2 of [G] (which is produced by **find**) into 4 orbits with respect to the group $C_2\times C_3$ generated by the sign reversal and the Frobenius automorphism.
4. **num_neighbors**: <br/>
This program, for a given $d$-dimensional simplicial complex $K$, computes the distribution of the numbers $s(\rho)$ for $(d-2)$-simplices $\rho$, where $s(\rho)$ is the number of $d$-simplices $\sigma\in K$ containing $\rho$. It was used to produce Table 4 in [G]. 
5. **num_neighbors_pairs**: <br/>
This program, for a given $d$-dimensional simplicial complex $K$ and two given vertices $u$ and $v$ of it, computes the matrix $(N_{pq})$, where $N_{pq}$ is the number of $(d-1)$-simplices $\tau\in K$ such that $u,v\in\tau$, $s(\tau\setminus \\{u\\})=p$, and $s(\tau\setminus \\{v\\})=q$. It was used to produce Tables 6-10 in [G]. 
6. **triples**: <br/>
 This program computes the $\nu$-parameters of simplices of a pure $d$-dimensional simplicial complex. Besides, when $K$ is a combinatorial manifold, it finds all distinguished subcomplexes, that is, subcomplexes of the form $(\Delta_1*\partial\Delta_2)\cup(\Delta_2*\partial\Delta_3)\cup(\Delta_3*\partial\Delta_1)$, where $\Delta_1$, $\Delta_2$, and $\Delta_3$ are $(d/2)$-simplices. Computations by means of this program yield Propositions 8.2 and 8.4 in [G].
7. **allsimp**: <br/>
This auxiliary script produces the list of all simplices in some $G$-invariant set from a given symmetry group $G$ and a list of representatives of $G$-orbits of the simplices in this set. 
8. **operations**: <br/>
This simple script performs basic operations (compairing, union, intersection, difference) for any set of strings. It can be conveniently used to check whether two simplicial complexes coincide, find a common part of two simplicial complexes, etc. In particular, it was used to produce Table 3 and Tables 11-20 in [G].   

Among these programs, the only two non-trivial are the programs **find** and **check**. For them, we will produce detailed descriptions below. The other programs are very simple. They do not require any special explanation.

## Input/output format

The files with the input data are to be put in the directory of the program (for instance, **find**). The output files also are written to the same directory. Below, we first describe the standard formats that are used for main types of data (symmetry group, simplex, simplicial complex), and then the input/output data for all the 8 programs listed above. 

The main object we are working with is a pure $d$-dimensional simplicial complex with $n$ vertices numbered from $1$ to $n$ with the given symmetry group $G$. In the most important for us case, $d=16$, $n=27$, and $|G|=351$. 

### Standard format for a group $G$

The following description of the symmetry $G\subset S_n$ should be provided in the file **symmetry_group.dat**. The first line of the file contains the degree $n$ of the permutation group. Further lines contain generators of $G$, one generator per line. Each generator is given in cycle notation, cycles are surrounded by round brackets, vertices in each cycle are separated by spaces. Additional spaces are irrelevant. Empty lines are not allowed.  For instance, the $351$-element group $G_{351}\subset S_{27}$ is given by the following file: 
```
27
(1 2 3 4 5 6 7 8 9 10 11 12 13)(14 15 16 17 18 19 20 21 22 23 24 25 26)
(1 14 27)(2 4 10)(3 22 13)(5 6 21)(7 25 11)(8 19 18)(9 16 26)(12 20 24)(15 23 17)
```

### Standard format for a simplex

We always encode simplices by variables of type `unsigned long int`. 

Inside the program, we number the vertices of a simplicial complex from $0$ to $n-1$ (where $n$ is the number of vertices). A variable `s` of type `unsigned long int` corresponding to a simplex has the $i^{th}$ from the right bit equal to $1$ whenever $i$ is a vertex of the simplex, and $0$ otherwise. (Here bits are also numbered starting from $0$.) For instance, the number
$1010111_2=87$ encodes the simplex $\\{0,1,2,4,6\\}$.

Nevertheless, in the I/O functions we conveniently reverse the sequence of bits (from left to right) and simultaneously pass to the numbering of vertices (and bits) starting from $1$ rather than from $0$, thus adding $1$ to all the numbers. Besides, we fix that the string of $0$'s and $1$'s encoding a simplex must contain exactly $n$ digits. For instance, the row 
```
111010100000000
``` 
in an I/O file will correspond to the number $1010111_2=87$ and hence to the simplex $\\{1,2,3,5,7\\}$ in a simplicial complex on $15$ vertices.


### Standard format for a simplicial complex

We typically work with rather large $G$-invariant simplicial complexes.

The file describing a simplicial complex is usually called **triang.dat**.

The first line of the description of a simplicial complex contains the number $k$ of $G$-orbits of maximal simplices. The consecutive $k$ lines contain rows of 0's and 1's encoding representatives of $G$-orbits of maximal simplices as described above. The smallest representative must be chosen in each orbit and these representatives must be ordered from smallest to largest (w.r.t. the ordering described above). For instance, a file describing a simplicial complex can look like that:
```
286
111111111111110111000000000
111111111111011111000000000
111111101111111111000000000
. . . . .
110111110010111001111110000
```

The file **triang.dat** does not contain a description of the group $G$. So, in fact, a simplicial complex is described only by the two files **symmetry_group.dat** and **triang.dat** together. 

### Program "find"

**Input data:**

+ A file **symmetry_group.dat** describing the symmetry group $G$ in the standard format.
+ A file **dimnum.dat** containing two numbers $d$ and $N$ separated by a space (or several spaces); the first number $d$ is the dimension of weak pseudomanifolds $K$ we are looking for, and the second number $N$ is the smallest number of $d$-simplices in $K$, for instance,  
`16 100386` <br/> 
     

**Output data:**

+ A file **triangulations.dat** containing the list of all weak pseudomanifolds found. The information about each pseudomanifold starts with the line of the form <br/> <br/> 
` *** <number of the pseudomanifold> ` <br/><br/>
after which follows the description of the pseudomanifold in the standard format. Different pseudomanifolds are separated by empty lines. The numbering of pseudomanifolds starts from 1. So the file  **triangulations.dat** looks like that 
    ```
    *** 1
    286
    111111111111110111000000000
    . . . . . 
    110111110010111001111110000

    *** 2
    286
    111111111111111110000000000
    . . . . . 
    001111110110111010111110000

    . . . . . 
    ```

+ A file **triangulations_with_sizes.dat** containing the same list with the additionally information on the cardinalities of the $G$-orbits of maximal simplices. The cardinality of each $G$-orbit is written directly after the representative of this orbit (separated by space). For instance,
    ```
    *** 1
    286
    111111111111110111000000000 351
    . . . . . 
    110111110010111001111110000 351

    *** 2
    286
    111111111111111110000000000 351
    . . . . . 
    001111110110111010111110000 351

    . . . . . 
    ```
### Program "check"

**Input data:**

+ A file **symmetry_group.dat** describing the symmetry group $G$ in the standard format.
+ A file **triang.dat** describing a pure simplicial complex $K$ in the standard format.

**Output data:**

The program **check** says whether it has succeeded to check that $K$ is a combinatorial manifold. So there are two possibilities:

+ If the program succeeds to check that $K$ is a combinatorial manifold, then the output is just the line
    ``` 
    This is a combinatorial manifold
    ```

+ If the program does not succeed to check that $K$ is a combinatorial manifold, then it writes the smallest representatives of $G$-orbits of simplices for which it has failed to check that their links are combinatorial spheres to the file **bad_simplices.dat** in the standard format. Besides, the program produces the line 
     ```
     There are <number of orbits of bad simplices> bad simplices
     ```
     

**Remark.** If a simplex is put to the list of *bad simplices*, it does not follow that its link is not a combinatorial sphere. A positive result guarantees that $K$ is a combinatorial manifold but a negative result does not guarantee that $K$ is not.

### Program "permute"

**Input data:**

+ A file **symmetry_group.dat** describing the symmetry group $G$ in the standard format.
+ A file **triang.dat** describing a pure simplicial complex $K$ in the standard format.
+ A file **permutation.dat** consisting of a single line that contains a permutation $h$ in cycle notation. (Cycles are surrounded by round brackets, vertices in each cycle are separated by spaces.)

**Output data:**

First, the program finds out whether the permutation $h$ normalizes the group $G$. If $h$ does not normalize $G$, then the only output is the line

```
The permutation does not belong to the normalizer of the group
```

Second, if $h$ belongs to the normalizer of $G$, then $h(K)$ is again a $G$-invariant simplicial complex. Then the output is a file **triang_new.dat** containing $h(K)$ in the standard format.


### Program "num_neighbors"

**Input data:**

+ A file **symmetry_group.dat** describing the symmetry group $G$ in the standard format.
+ A file **triang.dat** describing a $d$-dimensional pure simplicial complex $K$ in the standard format.

**Output data:**

+ A file **result.dat**. Each line of this file contains two numbers $s$ and $N_s$ separated by a space, where $N_s$ is the number of $(d-2)$-simplices $\rho\in K$ with $s(\rho)=s$. Recall that $s(\rho)$ is the number of $d$-simplices $\sigma\in K$ containing $\rho.$ For instance, the file **result.dat** can look like that: 

    ```
    3 849771
    4 1509651
    5 697788
    6 201942
    7 40716
    8 9477
    9 351
    ```
      
### Program "num_neighbors_pairs"

**Input data:**

+ A file **symmetry_group.dat** describing the symmetry group $G$ in the standard format.
+ A file **triang.dat** describing a $d$-dimensional pure simplicial complex $K$ in the standard format.
+ A file **edge.dat** containing two (different) numbers $u$ and $v$ separated by a space. These are numbers of vertices, so they must be in the range  from 1 to the total number of vertices $n$. 

**Output data:**

+ A file **result.dat**. The first line of this file contains a single number $s_{max}$ that is equal to the maximal among all numbers $s(\tau\setminus\\{u\\})$ and $s(\tau\setminus\\{v\\})$, where $\tau$ runs over all $(d-1)$-dimensional simplices $\tau\in K$ containing both $u$ and $v$. The next $s_{max}$ lines contain the $s_{max}\times s_{max}$ matrix $N_{pq}$, where $N_{pq}$ is the number of $(d-1)$-simplices $\tau\in K$ such that $u,v\in\tau$, $s(\tau\setminus \\{u\\})=p$, and $s(\tau\setminus \\{v\\})=q$. (The entries of each row of the matrix are separated by spaces.)


### Program "triples"

**Input data:**

+ A file **symmetry_group.dat** describing the symmetry group $G$ in the standard format.
+ A file **triang.dat** describing a $d$-dimensional pure simplicial complex $K$ in the standard format.
+ The program asks the user whether to look for distinguished triples or not. <br/>
**Remark.** The reason for this request is that the procedure for finding the distinguished triples works correctly only when $K$ is a combinatorial manifold and $n=3d/2+3$. Nevertheless, computing the $\nu$-parameters may be useful in other situations as well.
 
**Output data:** 

+ A file **nu_param.dat**. This file lists the (smallest) representatives of all $G$-orbits of $d$-simplices $\sigma\in K$ with at least one $\nu$-parameter greater than or equal to $d/2$. The first line of the file contains the number $q$ of such $G$-orbits. Each of the next $q$ orbits contains a simplex $\sigma$ (in the standard format), and the $\nu$-parameters $\nu_K(\sigma,v_i)$ for $i=1,\ldots,n-d-1$, where $v_1 <\cdots < v_{n-d-1}$ are all the vertices not belonging to $\sigma$. These numbers are separated with spaces, for instance, 

    ```
    110110011101100 1 1 2 0 4 1
    ```

+ If the user has chosen to look for distinguished triples, then the program also produces a file
**distinguished.dat** containing information on representatives of $G$-orbits of distinguished triples. The description of each distinguished triple $(\Delta_1,\Delta_2,\Delta_3)$ consists of 4 lines. The first 3 lines contain the simplices $\Delta_1$, $\Delta_2$, and $\Delta_3$ (in the standard format), and the last line indicates the *type* of the triple. (A distinguished triple has *type 1* if the three simplices $\Delta_1$, $\Delta_2$, and $\Delta_3$ lie in the same $G$-orbit, and has *type 2* otherwise.) Descriptions of different distinguished triples are separated by empty lines. An example of the description of a triple is as follows: 
 
    ```
    001100110001111010000000000
    110011001110000100000000100
    000000000000000001111111011
    type 2
    ```

### Program "allsimp"

**Input data:**

+ A file **symmetry_group.dat** describing the symmetry group $G$ in the standard format.
+ A file **triang.dat** containing the list of representatives of a set of $G$-orbits of simplices. (The first line contains the number of $G$-orbits of $K$; the following lines contain the representatives in the standard format.)

**Output data:**

+ A file **triang_all.dat**. The first line contains the total number of simplices in the given $G$-orbits; the following lines contain the list of all these simplices in the standard format. 

### Program "operations"

**Input data:**

+ Files **triang1.dat** and  **triang2.dat**. The first line of each of these two files contains a single number indicating the number of subsequent lines. Then follows an arbitrary set of strings (one per line) without spaces or tabulations or empty lines.  
+ The user is asked to choose the type of the operation:

    ```
    Input the type of the operation:
      1 compare
      2 union
      3 intersection
      4 difference
    ```
    
**Output data:**

+ For the operation **compare**, the program gives one of the four answers: <br/>
`The complexes coincide` <br/>
`The first complex is contained in the second one` <br/>
`The second complex is contained in the first one` <br/>
`Neither of the complexes is contained in the other one` <br/>

+ For the operation **union**, the program units the two lists of strings (removing repetitions) and writes the result to the file **triang_res.dat**. (Again, the first line contains the number of subsequent strings, and then follows the list of strings.) 

+ Similarly the operations **intersection** and **difference** yield the intersection and the difference (the first minus the second) of the two lists, respectively, which are also written to **triang_res.dat**.

## Common libraries 

### Library permutation.cpp / permutation.hpp

The library consists of a single class **Permutation** whose objects are permutations in the group $S_d$ for certain $d$. Note that inside the program we always interpret $S_d$ as the permutation group of the set $\\{0,\\ldots,d-1\\}$. Nevertheless, in I/O functions we always subtract 1/add 1 to all elements so that to obtain permutations of the set $\\{1,\\ldots,d\\}$.

A permutation $\nu\in S_d$ is stored in the variable 
```cpp
vector <int> seq;
```
where `seq[i]` is the value $\nu(i)$. Both `i` and `seq[i]` vary from $0$ to $d-1$. Besides, the class contains the variable
```cpp
bool well_defined;
```
that points out whether the permutation is well defined.

The class contains three contructors:
```cpp
Permutation (int deg);
Permutation (int deg, string cycle_structure);
Permutation (vector <int> & seq);
```
The first one produces the identity permutation of degree `deg`. 

The second constructor produces the permutation from the cycle notation of it. Note that, in the cycle notation, the elements are numbered from `1` to `deg`, so we subtract 1 from every element. For instance,
```cpp
Permutation nu (3, "(12)");
```
yields the permutation `nu` with `nu.seq[0]`, `nu.seq[1]`, and `nu.seq[2]` equal to $1$, $0$, and $2$, respectively.

The third constructor produces the permutation with the given vector `seq`. If the given vector does not provide a permutation, in the obtained object the variable `well_defined` will be `false`.

#### Member functions of the class Permutation

```cpp
int get_seq (int i) const;      // returns seq[i]
int degree () const;            // returns the degree of the permutation i.e. seq.size()
bool is_well_defined () const;  // returns well_defined
Permutation inv () const;       // returns the inverse element of the permutation group
```

For the objects of type **Permutation** are defined the overloaded operators `*` (multiplication in $S_d$), `==`, `!=`, and `<` (the lexicographic ordering).

We have one more overloaded operator
```cpp
unsigned long int Permutation::operator * (const unsigned long int & s) const;
```
The value `nu * s`, where `nu` and `s` are of types `Permutation` and `unsigned long int`, respectively, is obtained from `s` by permuting the `nu.deg()` rightmost bits of `s` according to `nu`. (Here, the rightmost bit has the number $0$, the next one has the number $1$, etc.) The reason is as follows. Recall that we encode a simplex by a variable of type `unsigned long int` so that the $i^{th}$ from the right bit indicates whether the simplex contains the vertex $i$. So `nu * s` corresponds to the action of `nu` on the simplex encoded by `s`. 

### Library myiofunctions.cpp / myiofunctions.hpp

The library contains mostly I/O functions. Let us list the functions with short descriptions of them.

```cpp
bool generate_group (ifstream & file, int & degree, int & group_order,
                     vector <Permutation> & group_elements);
```       

The function reads from `file` a permutation group $G\subset S_d$ in the standard format (see above). All elements of the group $G$ are written to the vector `group_elements` in some order. (Note that we pass from the numbering of the vertices starting from $1$ in `file` to the numbering of the vertices starting from $0$ in the objects of class **Permutation**.) The variables `degree` and `group_order` are set to be equal to $d$ and to $|G|$, respectively.  

```cpp
void print_simplices (ofstream & file, int number_of_vertices,
                      const set <unsigned long int> & simplices);
```
The function writes to `file` the set of simplices `simplices` in the standard standard. Recall that this means that the number `simplices.size()` is written to the first line, and each of the following lines contains a sequence of binary digits encoding the corresponding simplex (i.e. the `number_of_vertices` rightmost bits of `simplices[i]` in the reversed order). The parameter `number_of_vertices' must be equal to the total number of vertices of the simplicial complex.     


```cpp
unsigned long int string_to_simplex (int & num, const string & str);
unsigned long int string_to_simplex (const string & str);
```
The function transforms a string of $0$'s and $1$'s to the binary number of type `unsigned long int` encoding the corresponding simplex. (Recall that this is done by reversing the sequence.) The variable `num` (if present) is set to be equal to the number of vertices of the simplex i.e. to the number of $1$'s in `str`.


```cpp
string simplex_to_string (int number_of_vertices, unsigned long int s);
```
The functions transforms a varible `s` of type `unsigned long int` encoding a simplex to the string describing this simplex in the standard I/O format. Recall that this is done by reversing the sequence of sequence of bits of `s` and reducing its length to `number_of_vertices`, where `number_of_vertices` must be equal to the number of vertices of the simplicial complex. 


```cpp
int num_vert (int number_of_vertices, unsigned long int s);
```
The function computes the number of vertices of a simplex `s` in a simplicial  with `number_of_vertices` vertices.

```cpp
bool read_triang (ifstream & file, int number_of_vertices,
                  int & number_of_vertices_in_simplex,
                  int & number_of_orbits, set <unsigned long int> & orbit_rep);
bool read_triang (ifstream & file, int number_of_vertices,
                  set <unsigned long int> & orbit_rep);
```
The function reads from `file` a simplicial complex in the standard format (see above). The parameter `number_of_vertices` must be equal to the number of vertices of the complex. The simplices in `file` are transformed to the type `unsigned long int` and joined into the set `orbit_rep`. The variables `number_of_vertices_in_simplex` and `number_of_orbits` (if present) are set tobe equal to the number of vertices of each simplex (all these numbers are supposed to be equal to each other) and to the number of simplices in `file`, respectively.

## Program "find"

This program is an implementation of the algorithm described in Section 4 of [G]. We are not going to duplicate this description here. Also we are not going to duplicate here multiple comments in the files **find.cpp** and **find.hpp**. So here we shall give only several general comments on technical issues concerning the implementation of the algorithm. 

* The algorithm in Section 4 of [G] consists of two Stages. 
   + *Stage 1: Initial generation of admissible orbits and adjacency groups and initial prohibition of certain pairs of orbits*. This stage is governed by the function
        ```cpp
         void generate_orbits_and_adjacency_groups ();
        ```
   + *Stage 2: Selection of orbits*. This stage is governed by the function
        ```cpp
        void selection ();
        ```
* The selection of orbits looks roughly as follows. We examine one-by-one the adjacency groups trying to improve our knowledge on orbits that have to be taken or removed and pairs of orbits that have to be prohibited or required. The examination of an adjacency group is governed by the function
   ```cpp 
   bool examine (int agnum);
   ```
   After this process stops, we have to branch the algorithm. This means that we choose an indeterminate (i.e.    neither taken nor removed) orbit $\\mathfrak{a}$ (which we shall further refer to as the **branch orbit**), and try to first take it and then to remove it. A heuristic algorithm for choosing a branch orbit is provided by the function
   ```cpp
   int_orbit choose_orbit ( );
   ```
* We introduce the following key concept of **level**. Initially, we are on level 1. Every time we choose a branch orbit $\\mathfrak{a}$ and decide to take it, we increase the level by 1. When we finish exploring the branch in which $\\mathfrak{a}$ is taken and pass to the branch in which $\\mathfrak{a}$ is removed, we decrease the level by 1 back. So at every moment, the level is equal to the number of branch orbits that are currently chosen to be taken plus 1. Note that we increase the level only when taking a **branch orbit**. If we deduce that some orbit must be taken during examining the adjacency groups, then we take this orbit without increasing the level. So the total number of currently taken orbits is typically much greater than the level.
* While examining the adjacency groups, we make decisions such as *to take an orbit* or *to remove an orbit* or *to prohibit a pair of orbits* or *to add a requirement* $\\mathfrak{a}\\to\\mathfrak{b}$. Every such decision is made on the assumption that some branch orbits have already been taken. In other words, every decision is taken on some level $k$. When we decrease the level from $k$ to $k-1$, we need to cancel all decisions made on level $k$. Technically, this is organized as follows:
    + We number all the adjacency orbits and introduce the vector 
         ```cpp
         vector <int_level> status;
         ```
         where `status[i]`
         
      - is equal to $+k$ if the $i^{th}$ orbit is currently taken and the decision to take it was made on level $k$,
      - is equal to $-k$ if the $i^{th}$ orbit is currently removed and the decision to remove it was made on level $k$,
      - is equal to $0$ if  the $i^{th}$ orbit is currently neither taken nor removed.
    
    + Similarly, we introduce the matrix
        ```cpp
        vector < vector <int_level> > relative_status;
        ```
        where `relative_status[i][j]`
         
      - is equal to $+k$ if the $i^{th}$ orbit requires the $j^{th}$ orbit the decision was made on level $k$,
      - is equal to $-k$ if the $i^{th}$ orbit prohibits the $j^{th}$ orbit the decision was made on level $k$,
      - is equal to $0$, otherwise.
    + Every time we decrease the level from $k$ to $k-1$, we change to $0$ all values `status[i]` and `relative_status[i][j]` that are equal to $\pm k$. 
    
* We typically have about $10^5$ admissible orbits. Hence the matrix `relative_status` contains about $10^{10}$ entries. This is why storing this matrix requires a lot of memory. To save memory, we use the type `int_level = signed char` for the elements of this matrix. However, this may cause a mistake if the level becomes greater than $127$. This has never happened in any examples that I have considered. Moreover, the level has been never greater than $20$. Nevertheless, if in some example the level became equal to $127$, one would need to change the definition of the type in the beginning of **find.hpp**
   ```cpp
   #define int_level signed char
   ```
    say, to `signed short`. <br/> For the same reason to save memory, we use the type 
    ```cpp
    #define int_orbit unsigned short int
    ```
    to store the numbers of admissible orbits. This works correctly unless the number of admissible orbits  is greater than $65535$. Otherwise, one needs to replace `unsigned short int` with  `unsigned long int`. 

## Program "check"

The program consists of two **cpp** files **check.cpp** and **simpmax.cpp** and a header file **simpmax.hpp**. 

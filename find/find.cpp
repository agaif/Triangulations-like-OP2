//
//  find.cpp
//  version 2
//
//  (C) Alexander A. Gaifullin, 2023
//

#include <time.h>
#include "../common/permutation.hpp"
#include "../common/myiofunctions.hpp"
#include "find.hpp"

#define ofile_name_with_sizes "triangulations_with_sizes.dat"
#define ofile_name_wo_sizes "triangulations.dat"
#define ifile_name_group "symmetry_group.dat"
#define ifile_name_dimnum "dimnum.dat"
#define ifile_name_reqsimp "reqsimp.dat"
#define ofile_name_log "log.txt"

/*********************************
 *                               *
 *   BEGIN of global variables   *
 *                               *
 *********************************/

ofstream file_log;      /* stream for logs */

int number_of_vertices; /* The number of vertices in the complex */
int number_of_vertices_in_simplex;  /* The number of vertices in a maximal simplex */
int min_number_of_maximal_simplices;   /* The minimal number of maximal simplices
                                        * in the desired triangulation */
vector <Permutation> group_elements; /* The set of all elements of the symmetry group */
int group_order;           /* The order of the symmetry group */
int number_of_orbits;      /* The number of admissible orbits of maximal simplices  */
int number_of_adjacency_groups;       /* The number of adjacency groups  */
int_level current_level;   /* is equal to the number of choices made in favour of taking an orbit + 1 */
int_level maximal_level;   /* the maximal value of current_level achieved so far */
int number_of_triangulations = 0;  /* the number of desired triangulations found so far */

vector <unsigned long int> orbit_rep;   /* Vector of size number_of_orbits consisting
                                         * of representatives of orbits
                                         * of possible maximal simplices.
                                         * Each simplex is encoded by
                                         * an unsigned long int number as follows:
                                         * the i-th from the right digit is 1 if vertex i
                                         * belongs to the simplex and 0, otherwise.
                                         * (All digits except for the number_of_vertices
                                         * rightmost are always 0.)
                                         * In each orbit, we choose those representative
                                         * which is smallest w.r.t. the usual order of unsigned int.
                                         * Vector orbit_rep is generated by generate_orbits ()
                                         * and never changes later; */
set <unsigned long int> initial_simp;   /* set of required simplices
                                         * is read from file reqsimp.dat
                                         */
vector <int> orbit_size;    /* vector of size number_of_orbits consisting of
                             * cardinalities of orbits of possible maximal simplices;
                             * is generated by generate_orbits ()
                             * and never changes later            */
set <int_orbit> orbits_taken;    /* the set of numbers of orbits that are currently taken  */
set <int_orbit> orbits_indeterminate; /* the set of numbers of orbits that are currently
                                       * indeterminate i.e. neither taken nor removed */
int current_number_of_maximal_simplices;   /* the total number of simplices in all orbits that
                                            * are currently not removed (i.e. taken or indeterminate) */
vector <int_level> status;   /* vector of size number_of_orbits of current status of orbits
                              * 0 if the orbit is neither taken nor removed
                              * k > 0 if the orbit was taken on level k
                              * -k < 0 if the orbit was removed on level k   */
vector < vector <int_level> > relative_status;   /* Square matrix of size number_of_orbits
                                    * relative_status[i][j] == k > 0 if
                                    * the orbit i requires the orbit j on level k
                                    * relative_status[i][j] == - k < 0 if
                                    * the orbit i prohibits the orbit j on level k
                                    * relative_status[i][i] is always 1
                                    * relative_status[i][j] == 0, otherwise.
                                    * The negative part of the matrix always remains symmetric
                                    * When we decrease level from k to k-1
                                    * all status and relative status equal to k or -k are turned to 0  */
vector < set <int> > adjacency_groups_containing_orbit;   /* Vector of size number_of_orbits;
                                        * adjacency_groups_containing_orbit[i] is the set of numbers of
                                        * all adjacency groups containing the given orbit */
vector < set <int_orbit> > adjacency_group;  /* Vector of size number_of_adjacency_groups;
                                              * adjacency_group[i] is the set of numbers of
                                              * orbits in the i-th adjacency group */
vector <int_orbit> number_of_taken_orbits_in_adjacency_group;
             /* Vector of size number_of_adjacency_groups;
              * i-th element is equal to the number of
              * taken orbits in the set adjacency_group[i] */
 
vector <int_orbit> number_of_possible_orbits_in_adjacency_group;
             /* Vector of size number_of_adjacency_groups;
              * i-th element is equal to the number of
              * orbits in the set adjacency_group[i]
              * that are not removed       */

stack <int_orbit> orbits_chosen_to_take;    /* consists of numbers of orbits arbitrarily chosen
                                             * to be taken while increasing level;
                                             * always consists of current_level - 1 elements;
                                             * after decreasing the level, the orbit at
                                             * the top of the stack is removed  */
set <int> adjacency_groups_to_be_examined;   /* The waiting list of adjacency orbits */

/*******************************
 *                             *
 *   END of global variables   *
 *                             *
 *******************************/


/****************************************************
 *                                                  *
 *   BEGIN of functions for the action on subsets   *
 *                                                  *
 ****************************************************/

set <unsigned long int> minimize_simplices (set <unsigned long int> & simplices) {
    set <unsigned long int> smallest_reps;
    for (auto s : simplices) {
        unsigned long int smin = s;
        for (auto g : group_elements) {
            unsigned long int t = g * s;
            if (t < smin) smin = t;
        }
        smallest_reps.insert(smin);
    }
    return smallest_reps;
}

/* Function ifsmallest_subset (s) returns true if the subset s
 * is the smallest in its orbit and returns false, otherwise. */

bool ifsmallest_subset (unsigned long int s) {
    for (auto g : group_elements) {
        if (s > g * s) return false;
    }
    return true;
}

/* Function next_subset (s) returns the next (w.r.t. the usual ordering)
 * unsigned long int that has the same number of nonzero digits as s does. */

unsigned long int next_subset (unsigned long int s) {
    unsigned long int q = s;
    int i = 0, j = 0;
    while (q % 2 == 0) {
        q = q >> 1;
        i++;
    }                   // i is the number of consecutive 0's at the end of s
    while (q % 2 == 1) {
        q = q >> 1;
        j++;
    }                   // j is the number of consecutive 1's before
                        // the last i consecutive 0's
    q++;
    q = q << (i + 1);
    q++;
    q = q << (j - 1);
    q--;
    return q;
}

/**************************************************
 *                                                *
 *   END of functions for the action on subsets   *
 *                                                *
 **************************************************/

/***************************************************
 *                                                 *
 *   BEGIN of functions for initial generating     *
 *         the orbits of maximal simplices         *
 *                                                 *
 ***************************************************/

/* In the five functions below, we temporarily store information about
 * orbits of codimension 1 faces using type
 * map <unsigned long int, pair <set <int_orbit>, set <int_orbit> > >
 * The Key indicates (the smallest) representative
 * of an orbit of a codim 1 faces.
 * The first set <int_orbit> in the pair is the set of the numbers of orbits
 * of maximal simplices that are ONCE adjacent to the codim 1 face.
 * The second set <int_orbit> in the pair is the set of the numbers of orbits
 * of maximal simplices that are TWICE adjacent to the codim 1 face considered.
 */

/* Function try_to_add_orbit (s, all_face_orbits)
 * determines whether the orbit of s is admissible and, if so,
 * pushes_back s to orbit_rep, pushes_back the cardinality of the orbit of s to orbit_size
 * (and adds it to current_number_of_maximal_simplices),
 * sets the status of the new orbit to 0, and updates
 * information about codimension 1 faces stored in all_face_orbits.
 * When we call this function, it is always presupposed that s
 * contains exactly number_of_vertices_in_simplex nonzero digits
 * and is minimal in its orbit.
 */

void try_to_add_orbit (unsigned long int s, map <unsigned long int, pair <set <int_orbit>, set <int_orbit> > > & all_face_orbits) {
    
    map <unsigned long int, pair <int, int> > new_face_orbits;
    /* The Key of type is the smallest representative of
     * the orbit of a codimension 1 face of the simplex s.
     * The first int in the pair indicates how many codimension 1
     * faces of s are in this orbit;
     * the second int is the order of the stabilizer of the face.
     */
    
    // compute the size of stabilizer of s
    int size_of_stabilizer = 0;
    for (auto g : group_elements) {
        unsigned long int r = g * s;
        if ( (r | s) == (1UL << number_of_vertices) - 1 ) { return; } /* If the union of r and s
                                                                       * is the set of all vertices,
                                                                       * then s is not admissible
                                                                       */
        for (auto t : initial_simp) {
            if ( (r | t) == (1UL << number_of_vertices) - 1 ) { return; }
        }                              /* If the union of r with a required simplex
                                        * is the set of all vertices,
                                        * then s is not admissible
                                        */

        if ( r == s ) { ++size_of_stabilizer; }
    }
    
    for (int i = 0; i < number_of_vertices; i++) {   // the cycle over all codim 1 faces of s
        if ( ( s & (1UL << i) ) == 0 ) {continue;}   // skip i that do not belong to simplex s
        
        
        unsigned long int t = s ^ (1UL << i);        // codim 1 face of s
        
        // Find the smallest representative t_min in the orbit of t
        // and compute the order of the stabilizer of t
        unsigned long int t_min = t;
        int size_of_face_stabilizer = 0;
        for (auto g : group_elements) {
            unsigned long int r = g * t;
            if (r < t_min) {t_min = r;}
            if ( r == t ) { ++size_of_face_stabilizer; }
        }
        
        // Write information to new_face_orbits
        if ( new_face_orbits.count(t_min) == 0 ) {
            new_face_orbits[t_min] = {1, size_of_face_stabilizer};
        } else {
            ++ new_face_orbits[t_min].first;
        }
        
        if (new_face_orbits[t_min].first * new_face_orbits[t_min].second > 2 * size_of_stabilizer) {
            return;      /* This inequality holds if and only the orbit of s
                          * is adjacent to t at least 3 times.
                          * In this case s is not admissible
                          */
        }
    }
    
    // Adding the orbit of s
    int_orbit number = orbit_rep.size();
    orbit_rep.push_back(s);
    status.push_back(0);
    int size_of_orbit = group_order / size_of_stabilizer;
    current_number_of_maximal_simplices += size_of_orbit;
    orbit_size.push_back(size_of_orbit);
    
    // Writing information about orbits of faces of s to all_face_orbits
    for (auto x : new_face_orbits) {
        if (all_face_orbits.count (x.first) == 0) {
            pair <set <int_orbit>, set <int_orbit> > new_face;
            all_face_orbits[x.first] = new_face;
        }
        if (x.second.first * x.second.second == size_of_stabilizer) {
            /* The product in the left hand side
             * is either size_of_stabilizer or 2 * size_of_stabilizer.
             * This determines whether the orbit of s is adjacent
             * to t once or twice.
             */
            all_face_orbits[x.first].first.insert (number);
        } else {
            all_face_orbits[x.first].second.insert (number);
        }
    }
}

/* The function generate_orbits (...) generates admissible orbits of possible maximal simplices
 * by calling successfully the function try_to_add_orbit (...) for all
 * subsets that consist of number_of_vertices_in_simplex elements
 * and are the smallest representatives of their orbits
 */
void generate_orbits (map <unsigned long int, pair <set <int_orbit>, set <int_orbit> > > & all_face_orbits) {
    /*****   writing log   ****/
    cout << "Generating admissible orbits...\n";
    /***** end writing log ****/
    
    current_number_of_maximal_simplices = 0;
    for (unsigned long int s = (1UL << number_of_vertices_in_simplex) - 1; s < (1UL << number_of_vertices); s = next_subset (s) ) {
   
        if ( ifsmallest_subset(s) ) {
            try_to_add_orbit(s, all_face_orbits);
        }
    }
    number_of_orbits = orbit_rep.size();
    
    /*****   writing log   ****/
    cout << number_of_orbits << " admissible orbits generated\n";
    if (type_log != 'n') {
        file_log << number_of_orbits << " admissible orbits generated\n";
    }
    /***** end writing log ****/
}

/**** Function initialize_relative_status () ****/
void initialize_relative_status () {
    /*****   writing log   ****/
    cout << "Prohibiting pairs...\n";
    /***** end writing log ****/
    int number_of_prohibited_pairs = 0;
    
    relative_status.resize(number_of_orbits);
    for (int_orbit n = 0; n < number_of_orbits; n++) {relative_status[n].resize(number_of_orbits);}
    
    
    for (int_orbit m = 0; m < number_of_orbits; m++) {
        relative_status[m][m] = 1;                 // diagonal entries
        set <unsigned long int> subsets_in_first_orbit;
        for (auto g : group_elements) {
            subsets_in_first_orbit.insert(g * orbit_rep[m]);
        }
        for (int_orbit n = 0; n < m; n++) {
            relative_status[m][n] = 0;             // non-diagonal entries
            relative_status[n][m] = 0;
            for (auto s : subsets_in_first_orbit) {
                if ( ( s | orbit_rep[n] ) == (1UL << number_of_vertices) - 1 ) {
                    relative_status[m][n] = -1;    // such pairs of orbits prohibit each other
                    relative_status[n][m] = -1;    // by complementarity
                    ++ number_of_prohibited_pairs;
                    break;
                }
            }
        }
    }
    
    /*****   writing log   ****/
    cout << number_of_prohibited_pairs << " pairs of orbits prohibited\n";
    if (type_log != 'n') {
        file_log << number_of_prohibited_pairs << " pairs of orbits prohibited\n";
    }
    /***** end writing log ****/
}

/* Function add_adjacency_group(...) receives the set of numbers
 * of orbits of maximal simplices
 * that are once adjacent to the face and
 * that are twice adjacent to the face.
 * 1) It prohibits all pairs (m,n), where m is twice adjacent
 * and n is either once or twice adjacent.
 * 2) An adjacency group is created consisting
 * of once adjacent orbits of maximal simplices
 */
void add_adjacency_group (set <int_orbit> & orbits_once_adjacent, set <int_orbit> & orbits_twice_adjacent) {
    // prohibiting pairs (m,n) with m twice adjacent and n either once or twice adjacent
    for (auto m : orbits_twice_adjacent) {
        for (auto n : orbits_twice_adjacent) {
            if (m != n) {
                relative_status[m][n] = -1;
            }
        }
        for (auto n : orbits_once_adjacent) {
            relative_status[m][n] = -1;
            relative_status[n][m] = -1;
        }
    }
    // Adding a new set of once adjacent orbits to adjacency_group.
    // (There is no need to do this if there are no once adjacent orbits.)
    if (!orbits_once_adjacent.empty()) {
        int agnum = adjacency_group.size();   /* the number of a new adjacency group equals
                                              * the number of previously added adjacency groups */
        adjacency_group.push_back(orbits_once_adjacent);
        number_of_taken_orbits_in_adjacency_group.push_back(0); // no orbits are taken so far
        number_of_possible_orbits_in_adjacency_group.push_back(orbits_once_adjacent.size());
                                                           // all orbits are possible so far
        for (auto n : orbits_once_adjacent) {
            adjacency_groups_containing_orbit[n].insert(agnum);
            /* adding the number of the new adjacency group to the list of
             * all adjacency groups containing orbit number n */
        }
    }
}

/* The function generate_adjacency_groups generates orbits of possible codim 1 faces
 * by calling successfully the function add_adjacency_group for all faces in all_face_orbits.
 */
void generate_adjacency_groups (map <unsigned long int, pair <set <int_orbit>, set <int_orbit> > > & all_face_orbits) {
    /*****   writing log   ****/
    cout << "Generating adjacency groups...\n";
    /***** end writing log ****/
    
    adjacency_groups_containing_orbit.resize(number_of_orbits);
    for (auto x : all_face_orbits) {
        add_adjacency_group (x.second.first, x.second.second);
    }
    number_of_adjacency_groups = adjacency_group.size();
    
    /*****   writing log   ****/
    cout << number_of_adjacency_groups << " adjacency groups generated\n\n";
    if (type_log != 'n') {
        file_log << number_of_adjacency_groups << " adjacency groups generated\n\n";
    }
    /***** end writing log ****/
}


// The main function in this group governing initial generation of data
void generate_orbits_and_adjacency_groups () {
    map <unsigned long int, pair <set <int_orbit>, set <int_orbit> > > all_face_orbits;
    generate_orbits (all_face_orbits);     // generate admissible orbits
    initialize_relative_status ();         // initial prohibiting of pairs of orbits
    generate_adjacency_groups (all_face_orbits);      // generate adjacency groups
}

/***************************************************
 *                                                 *
 *     END of functions for initial generating     *
 *         the orbits of maximal simplices         *
 *                                                 *
 ***************************************************/

/***********************************************************************
 *                                                                     *
 *     BEGIN of functions for taking/removing/requiring/prohibiting    *
 *           the orbits (the pairs of orbits) of maximal simplices     *
 *                                                                     *
 ***********************************************************************/

// All functions in this group return 'false' if
// a contradiction occurs and
// we need to stop considering this branch of the algorithm
// and decrease level, and return 'true' otherwise

// the function that takes one orbit
bool take_one_orbit (int_orbit number) {
    if (status[number] > 0) { return true; }   // no need to do anything if already taken
    if (status[number] < 0) { return false; }  // no possibility to take if already removed
    
    status [number] = current_level;           // taking the orbit
    orbits_indeterminate.erase(number);
    orbits_taken.insert(number);
    
    bool more_than_two_adjacent_orbits = false; // A variable indicating whether now there are
                                                // more than 2 taken vertices in some adjacent group
    
    
    // adding adjacent groups containing the new taken orbit to the waiting list
    // and modifying their parameters
    for (auto agnum : adjacency_groups_containing_orbit[number]) {
        ++number_of_taken_orbits_in_adjacency_group[agnum];
        if (number_of_taken_orbits_in_adjacency_group[agnum] > 2) {
            more_than_two_adjacent_orbits = true;
        }
        put_to_waiting_list (agnum);
    }
    
    if (more_than_two_adjacent_orbits) return false; // it is not allowed to have more than two taken
                                                     // orbits in an adjacency group
    
    /***** writing log ****/
    if (current_level == 1 && type_log != 'n') {
        file_log << simplex_to_string(number_of_vertices, orbit_rep[number]) << " eventually taken\n";
    } else if (type_log == 'f') {
        file_log << simplex_to_string(number_of_vertices, orbit_rep[number]) << " taken at level " << (int) current_level << "\n";
    }
    /***** end writing log ****/
    
    return true;
}

// the function that removes one orbit
bool remove_one_orbit (int_orbit number) {
    if (status[number] < 0) { return true; }     // no need to do anything if already removed
    if (status[number] > 0) { return false; }    // no possibility to remove if already taken
    
    // checking that the number of possible simplices will not become too small
    if (current_number_of_maximal_simplices - orbit_size [number] < min_number_of_maximal_simplices) {
        return false;
    }
    
    
    status [number] = - current_level;     // removing the orbit
    orbits_indeterminate.erase(number);
    current_number_of_maximal_simplices -= orbit_size [number];
    
    // adding adjacent groups containing the new removed orbit to the waiting list
    // and modifying their parameters
    for (auto agnum : adjacency_groups_containing_orbit[number]) {
        --number_of_possible_orbits_in_adjacency_group[agnum];
        put_to_waiting_list (agnum);
    }
    
    /***** writing log ****/
    if (current_level == 1 && type_log != 'n') {
        file_log << simplex_to_string(number_of_vertices, orbit_rep[number]) << " eventually removed\n";
    } else if (type_log == 'f'){
        file_log << simplex_to_string(number_of_vertices, orbit_rep[number]) << " removed at level " << (int) current_level << "\n";
    }
    /***** end writing log ****/
    
    return true;
}


// the function that adds one requirement m -> n
// there is no check of a possibility to add a requirement:
// the function is called only when such such check is already done
void require_one_pair (int_orbit m, int_orbit n) {
    if (m == n || status[m] < 0 || status [n] > 0 || relative_status[m][n] > 0) {return;}
    // no need to do anything in these cases
    
    relative_status[m][n] = current_level;  // adding a requirement
    
    // putting to the waiting list the adjacency groups
    // that contain both orbits in the requirement
    for (auto agnum : adjacency_groups_containing_orbit[m]) {
        if (adjacency_groups_containing_orbit[n].count(agnum) > 0) {
            put_to_waiting_list (agnum);
        }
    }
}

// the function that prohibits a pair of orbits
// there is no check of a possibility to add a requirement:
// the function is called only when such such check is already done
void prohibit_one_pair (int_orbit m, int_orbit n) {
    if (status[m] < 0  || status[n] < 0 || relative_status[m][n] < 0) {return;}
    // no need to do anything in these cases
    
    relative_status[m][n] = - current_level; // prohibiting the pair
    relative_status[n][m] = - current_level;
    
    // putting to the waiting list the adjacency groups
    // that contain both orbits
    for (auto agnum : adjacency_groups_containing_orbit[m]) {
        if (adjacency_groups_containing_orbit[n].count(agnum) > 0) {
            put_to_waiting_list (agnum);
        }
    }
}

// the function that takes an orbit and performs all takings and removings
// that are logical consequences of this taking
bool take (int_orbit n) {
    if (status[n] > 0) { return true; }      // no need to do anything if already taken
    if (status[n] < 0) { return false; }     // no possibility to take if already removed
    
    set <int_orbit> to_be_taken, to_be_removed;  // sets of orbits that are to be taken/removed
    
    for (auto m : orbits_indeterminate) {
        if (relative_status[n][m] > 0) {   // going to take all orbits required by the given one
            to_be_taken.insert(m);         // including itself, since relative_status[n][n] == 1
            continue;
        }
        if (relative_status[n][m] < 0) {   // going to remove all orbits prohibited by the given one
            to_be_removed.insert(m);
        }
    }
    
    for (auto m : to_be_taken) {           // taking the orbits
        if (!take_one_orbit (m)) return false;
    }
    
    for (auto m : to_be_removed) {         // removing the orbits
        if (!remove_one_orbit (m)) return false;
    }
    
    return true;
}

// the function that removes an orbit and performs all removings
// that are logical consequences of this removing
bool remove (int_orbit n) {
    if (status[n] < 0) { return true; }     // no need to do anything if already removed
    if (status[n] > 0) { return false; }    // no possibility to remove if already taken
    
    set <int_orbit> to_be_removed;          // set of orbits that are to be removed
    
    for (auto m : orbits_indeterminate) {
        if (relative_status[m][n] > 0) {    // going to remove all orbits required by the given one
            to_be_removed.insert(m);        // including itself, since relative_status[n][n] == 1
        }
    }
    
    for (auto m : to_be_removed) {          // removing the orbits
        if (!remove_one_orbit (m)) return false;
    }
    
    return true;
}


// the function that adds a requirement and all its logical consequences
bool require (int_orbit m, int_orbit n) {
    
    if (m == n || status[m] < 0 || status[n] > 0 || relative_status[m][n] > 0) {return true;}
         // no need to do anything in these cases

    if (status[m] > 0) {return take(n);}  // adding a requirement by an orbit that is already taken
                                          // means that we need to take n as well
                                          // (with all logical consequences)
    
    if (status[n] < 0 || relative_status[m][n] < 0) {return remove(m);}
           // trying to require an orbit that is already removed or is prohibited by m
           // means that we need to remove m as well
    
    set <int_orbit> to_be_removed;        // the set of orbits to be removed
    set <int_orbit> those_who_require;    // the set of orbits that will start
                                          // requiring the orbits in the set to_be_required and
                                          // prohibiting the orbits in the set to_be_prohibited
    set <int_orbit> to_be_required, to_be_prohibited; // the sets of orbits to be required/prohibited
                                                      // by the orbits in those_who_require
    
    for (auto p : orbits_indeterminate) {
        if (relative_status[p][m] > 0) {
            if (relative_status[p][n] < 0) {
                to_be_removed.insert(p);  // going to remove all orbits that require m and
                continue;                 // are prohibited by n
            }
            those_who_require.insert(p);  // orbits that require m
        }
        
        if (relative_status[n][p] > 0) {
            to_be_required.insert(p);   // if an orbit was required by n, it becomes required by m
            continue;                   // and by all orbits that require m
        }
        
        if (relative_status[n][p] < 0) {
            to_be_prohibited.insert(p); // if an orbit was prohibited by n, it becomes prohibited by m
                                        // and by all orbits that require m
        }
    }
    
    for (auto p : to_be_removed) {      // removing the orbits
        if (! remove_one_orbit(p)) return false;
    }

    for (auto p : those_who_require) {  // adding the requirements
        for (auto q : to_be_required) {
            require_one_pair (p, q);
        }
        
        for (auto q : to_be_prohibited) { // adding the prohibitions
            prohibit_one_pair (p, q);
        }
    }
    
    return true;
}


// the function that adds a prohibition and all its logical consequences
bool prohibit (int_orbit m, int_orbit n) {
    
    if (m == n || status[n] > 0) {return remove(m);}   // if one of the orbits is taken
    if (status[m] > 0) {return remove(n);}             // (or the orbits coincide),
                                                       // we need to remove the other orbit
    if (status[m] < 0 || status [n] < 0 || relative_status[m][n] < 0) {return true;}
             // no need to do anything in these cases
    
    set <int_orbit> to_be_removed;          // the set of orbits to be removed
    set <int_orbit> to_be_prohibited_first, to_be_prohibited_second;
    // sets of orbits such that every orbits in the first is going to prohibit every orbit in the second
    
    for (auto p : orbits_indeterminate) {
        if (relative_status[p][m] > 0 && relative_status[p][n] > 0) { // if p requires two conflicting
            to_be_removed.insert(p);                                  // orbits, it is to be removed
            continue;
        }
        
        // orbits requiring m are going to become conflicting with orbits requiring n
        if (relative_status[p][m] > 0) {
            to_be_prohibited_first.insert(p);
            continue;
        }
        if (relative_status[p][n] > 0) {
            to_be_prohibited_second.insert(p);
        }
    }
    
    for (auto p : to_be_removed) {          // removing the orbits
        if (! remove_one_orbit(p) ) return false;
    }
    
    for (auto p : to_be_prohibited_first) { // adding the prohibitions
        for (auto q : to_be_prohibited_second) {
            prohibit_one_pair (p,q);
        }
    }
    
    return true;
}

/***********************************************************************
 *                                                                     *
 *       END of functions for taking/removing/requiring/prohibiting    *
 *           the orbits (the pairs of orbits) of maximal simplices     *
 *                                                                     *
 ***********************************************************************/

// ************************************************
//
//       BEGIN of functions for updating groups of simplices corresponding to codimension 1 faces
//
//*************************************************

// The function that puts the adjacency group with number agnum
// to the waiting list to be examined.
// The adjacency group is not put to the waiting list if it is already 'finished'
// that means that it contains either 0 or 2 taken orbits and no indeterminate orbits.
void put_to_waiting_list (int agnum) {
    if ( number_of_possible_orbits_in_adjacency_group [agnum] == 0 ||
        (number_of_possible_orbits_in_adjacency_group [agnum] == 2 &&
         number_of_taken_orbits_in_adjacency_group [agnum] == 2)) return;
    adjacency_groups_to_be_examined.insert(agnum);
}


// The function that examines an adjacency group containing two taken orbits
bool examine_with_taken_two (int agnum) {
    for (auto n : adjacency_group[agnum]) {
        if (status[n] == 0) {        // removing all indeterminate orbits in the adjacency group
            if (! remove (n) ) {return false;}
        }
    }
    adjacency_groups_to_be_examined.erase (agnum); // erasing the group from the waiting list
    return true;
}


// the function that examines an adjacency group containing one taken orbit
bool examine_with_taken_one (int agnum) {
    if (number_of_possible_orbits_in_adjacency_group [agnum] == 1) {return false;}
            // a contradiction if there are no other possible orbits
    
    // if there is only one another possible orbit, we take it
    if (number_of_possible_orbits_in_adjacency_group [agnum] == 2) {
        for (auto n : adjacency_group[agnum]) {
            if (status[n] == 0) {
                if (! take(n) ) {return false;}
                break;
            }
        }
        adjacency_groups_to_be_examined.erase (agnum); // erasing the group from the waiting list
        return true;
    }
    
    vector <int_orbit> adjacent_indetermined; // all indeterminate orbits in the adjacency group
    for (auto n : adjacency_group[agnum]) {
        if (status[n] == 0) {
            adjacent_indetermined.push_back(n);
        }
    }
    for (auto n : adjacent_indetermined) {  // prohibiting all pairs of indeterminate orbits in the group
        for (auto m : adjacent_indetermined) {
            if (m >= n) {continue;}
            if (! prohibit (m,n)) {return false;}
        }
    }
    adjacency_groups_to_be_examined.erase (agnum);   // erasing the group from the waiting list
    return true;
}


// The function that examines an adjacency group containing no taken orbits:
// Step 1: Removing all orbits that require at least 2 other orbits in the adjacency group
bool examine_with_taken_zero_step1 (int agnum) {
    
    for (auto n : adjacency_group[agnum]) {
        if (status[n] != 0) continue;
        int_orbit number_of_required_in_group = 0;
        for (auto m : adjacency_group[agnum]) {
            if (m == n || status[m] != 0) continue;
            if (relative_status[n][m] > 0) {
                ++number_of_required_in_group;
                if (number_of_required_in_group > 1) {
                    if (! remove (n)) return false;
                    break;
                }
            }
        }
    }
    return true;
}
    
    
// The function that examines an adjacency group containing no taken orbits:
// Step 2: If there is a requirement n -> m inside the adjacency group,
// then we prohibit all pair {n,k}, where k are other indeterminate orbits in the same group
bool examine_with_taken_zero_step2 (int agnum) {
    
    for (auto n : adjacency_group[agnum]) {
        if (status[n] != 0) continue;
        for (auto m : adjacency_group[agnum]) {
            if (m == n || status[m] != 0) continue;
            if (relative_status[n][m] > 0) {
                for (auto k : adjacency_group[agnum]) {
                    if (k == m || k == n || status[k] != 0) continue;
                    if ( ! prohibit (n, k) ) return false;
                }
                break;
            }
        }
    }
    return true;
}


// The function that examines an adjacency group containing no taken orbits:
// Step 3: (a) if an orbit number n conflicts with all other indeterminate orbits in the adjacency group,
//             then we remove n;
//         (b) if an orbit number n conflicts with all other indeterminate orbits in the adjacency group,
//             except for one orbit, then this one orbit becomes required by n;
bool examine_with_taken_zero_step3 (int agnum) {
    for (auto n : adjacency_group[agnum]) {
        if (status[n] != 0) continue;

        int_orbit number_of_allowed_in_group = 0; // number of orbits in the adjacency group
                                                  // that do not conflict with the orbit number n
        int_orbit non_conflicting_orbit;          // number of the only orbit that does not
                                                  // conflict with the orbit number n

        for (auto m : adjacency_group[agnum]) {
            if (m == n || status[m] != 0) continue;
            
            if (relative_status[m][n] >= 0) {
                ++ number_of_allowed_in_group;
                if (number_of_allowed_in_group > 1) break;
                non_conflicting_orbit = m;
            }
        }
        
        if (number_of_allowed_in_group == 0) {  // removing n if it conflicts to all other orbits
            if (!remove(n)) return false;
            continue;
        }
        
        if (number_of_allowed_in_group == 1) {  // adding a requirement if there is only one possibility
            if (!require(n, non_conflicting_orbit)) return false;
        }
    }
    return true;
}

// the function that examines an adjacency group containing no taken orbits
bool examine_with_taken_zero (int agnum) {
    if (! examine_with_taken_zero_step1 (agnum) ) return false;
    if (! examine_with_taken_zero_step2 (agnum) ) return false;
    if (! examine_with_taken_zero_step3 (agnum) ) return false;
    adjacency_groups_to_be_examined.erase (agnum);   // erasing the group from the waiting list
    return true;
}

// the main function that examines an adjacency group by calling
// the corresponding function depending on the number of taken orbits in the group
bool examine (int agnum) {
    switch (number_of_taken_orbits_in_adjacency_group [agnum]) {
        case 2:
            return examine_with_taken_two (agnum);
            
        case 1:
            return examine_with_taken_one (agnum);
            
        case 0:
            return examine_with_taken_zero (agnum);
            
        default:             // if there are more than two taken orbits in the adjacency group
            return false;    // we have a contradiction
    }
}
    
// ************************************************
//
//       END of functions for updating groups of simplices corresponding to codimension 1 faces
//
//*************************************************

// ************************************************
//
//       BEGIN of functions for eliminating the orbits
//
//*************************************************


// A heuristic function for choosing an orbit in case
// we need to branch the algorithm
int_orbit choose_orbit ( ) {
    int best_orbit;
    int best_quality = 0;
    for (auto m : orbits_indeterminate) {
        int current_quality = 0;
        for (auto n : orbits_indeterminate) {
            if (relative_status[m][n] > 0) {current_quality += 10;}
            else if (relative_status[m][n] < 0) { ++ current_quality;}
        }
        if (current_quality > best_quality) {
            best_orbit = m;
            best_quality = current_quality;
        }
    }
    return best_orbit;
}


// The function that increases the level
bool increase_level() {
    
    int_orbit number = choose_orbit ();           // choosing an orbit that is taken (and later removed)
    orbits_chosen_to_take.push(number);           // adding the chosen orbit to the stack
    
    ++current_level;
    
    if (current_level > maximal_level) {
        maximal_level = current_level;
    }
    
    /***** writing log ****/
    if (type_log == 'f') {
        file_log << "(" << orbits_taken.size() << ", " << orbits_indeterminate.size() << ", "
            << number_of_orbits - orbits_taken.size() - orbits_indeterminate.size()
            << ") taken/indeterminate/removed orbits" << endl;
        file_log << "Raising to level " << (int) current_level << ": Trying "
            << simplex_to_string(number_of_vertices, orbit_rep[number]) << " "
            << orbit_size[number] << "\n";
    }
    /***** end writing log ****/
    
    return take (number);                 // taking the chosen orbit
}


// The function that decreases the level by 1
bool decrease_one_level() {
    
    /***** writing log ****/
    if (type_log == 'f') {
        file_log << "Returning to level " << (int) (current_level - 1) << "\n";
    }
    /***** end writing log ****/
    
    if (current_level == 1) { // if the level becomes 0, the process is over
        current_level = 0;
        return true;
    }
    
    for (int_orbit number = 0; number < number_of_orbits; number++) { // enumerateion over all orbits
        if (status[number] == current_level) {   // if the orbit was taken on the current level
            orbits_taken.erase(number);          // it becomes indeterminate and we change
            orbits_indeterminate.insert(number); // the parameters of containing it adjacency groups
            status[number] = 0;
            for (auto agnum : adjacency_groups_containing_orbit[number]) {--number_of_taken_orbits_in_adjacency_group[agnum];}
        }
        
        if (status[number] == - current_level) {  // if the orbit was removed on the current level
            orbits_indeterminate.insert(number);  // it becomes indeterminate and we change
            status[number] = 0;                   // the parameters of containing it adjacency groups
            current_number_of_maximal_simplices += orbit_size [number];
            for (auto agnum : adjacency_groups_containing_orbit[number]) {++number_of_possible_orbits_in_adjacency_group[agnum];}
        }
        
        // all prohibitions and requirements made on the current level are cancelled
        for (int_orbit another_num = 0; another_num < number_of_orbits; another_num++) {
            if (relative_status[number][another_num] == current_level || relative_status[number][another_num] == - current_level) {
                relative_status[number][another_num] = 0;
            }
        }
    }

    adjacency_groups_to_be_examined.clear();   // the waiting least of adjacency orbits is cleared
    
    int_orbit last_chosen_orbit = orbits_chosen_to_take.top(); // the top orbit is deleted from the stack
    orbits_chosen_to_take.pop();
    --current_level;
    
    return remove (last_chosen_orbit); // the last 'branch orbit' is removed
}

// the function that decreases the level until no contradiction occurs
void decrease_level() {
    while (!decrease_one_level());
}

// the function that computes the number of simplices that
// will be additionally prohibited if we take the orbit number n
int number_of_prohibited_simplices (int_orbit n) {
    int result = 0;
    for (auto m : orbits_indeterminate) {
        if ( relative_status[n][m] < 0 ) result += orbit_size [m];
    }
    return result;
}

// the function that removes all orbits that, if being taken,
// lead to prohibiting of so many simplices that the
// total number of simplices in taken and indeterminate orbits
// becomes smaller than
// min_number_of_maximal_simplices
bool eliminate_by_possible_number_of_simplices () {
    if (orbits_indeterminate.size() > 5 * min_number_of_maximal_simplices / group_order) {
        return false;
    }
    int max_possible_number_of_prohibited_simplices =
        current_number_of_maximal_simplices - min_number_of_maximal_simplices;
    
    set <int_orbit> to_be_removed;
    
    for (auto n : orbits_indeterminate) {
        if (number_of_prohibited_simplices (n) > max_possible_number_of_prohibited_simplices) {
            to_be_removed.insert (n);
        }
    }
    
    for (auto n : to_be_removed) {
        if (! remove (n) ) {
            decrease_level();
            return true;
        }
    }
    return ! to_be_removed.empty ();
}

// the function that takes the initially required orbits
bool take_initial_orbits () {
    set <unsigned long int> initial_simp_copy = initial_simp;
    for (int_orbit number = 0; number < number_of_orbits; number++ ) {
        if ( initial_simp_copy.count( orbit_rep[number]) != 0) {
            if (!take(number)) return false;
            initial_simp_copy.erase(orbit_rep[number]);
        }
    }
    return initial_simp_copy.empty();
}

// the function that governs the selection of orbits
void selection () {
    /***** writing log ****/
    cout << "Starting selection of orbits...\n";
    /***** end writing log ****/
    
    current_level = 1;
    maximal_level = 1;
    
    if (number_of_orbits == 0) return; // Nothing to do if no admissible orbits
    
    // making all orbits indeterminate
    for (int_orbit number = 0; number < number_of_orbits; number++ ) {
        orbits_indeterminate.insert (number);
    }
    
    // putting all adjacency groups to the waiting list
    for (int agnum = 0; agnum < number_of_adjacency_groups; agnum++) {
        put_to_waiting_list (agnum);
    }

    // taking required initial orbits
    if ( !take_initial_orbits () ) return;
    
    while (current_level > 0)  {
        
        // examine adjacency groups unless the waiting list is empty
        if ( ! adjacency_groups_to_be_examined.empty() ) {
            if (! examine (* adjacency_groups_to_be_examined.begin()) ) {
                decrease_level();
            }
            continue;
        }
        
        // If there are no indeterminate orbits, then a triangulation is found.
        if ( orbits_indeterminate.size() == 0 ) {
            triangulation_found();        // calling the function that prints the triangulation to file
            decrease_level();             // decreasing the level
            continue;
        }
        
        if (eliminate_by_possible_number_of_simplices ()) continue;
    
        // trying to increase the level, and then decreasing it back if a contradiction is reached
        if ( !increase_level() ) {decrease_level();}
    }
}

// ************************************************
//
//       BEGIN of functions for eliminating the orbits
//
//*************************************************

// ************************************************
//
//       BEGIN of output functions
//
//*************************************************

// the function that prints a triangulation to file
void triangulation_found () {
    
    ++ number_of_triangulations;   // increasing by 1 the number of found triangulations
    
    /***** writing log ****/
    cout << "Triangulation number " << number_of_triangulations << " found:" << endl;
    cout << orbits_taken.size() << " orbits, "
        << current_number_of_maximal_simplices << " simplices" << endl;
    if (type_log != 'n') {
        file_log << "Triangulation number " << number_of_triangulations << " found:" << endl;
        file_log << orbits_taken.size() << " orbits, "
            << current_number_of_maximal_simplices << " simplices" << endl;
    }
    /***** end writing log ****/
    
    ofstream file (ofile_name_wo_sizes, ios::app);
    ofstream file_sizes (ofile_name_with_sizes, ios::app);
    
    file << "*** " << number_of_triangulations << endl;
    file_sizes << "*** " << number_of_triangulations << endl;
    file << orbits_taken.size() << endl;
    file_sizes << orbits_taken.size() << endl;
    
    for (auto num_orb : orbits_taken) {
        string str = simplex_to_string (number_of_vertices, orbit_rep [num_orb]);
        file << str << endl;
        file_sizes << str << "  " << orbit_size[num_orb] << endl;
    }
    
    file << endl;
    file_sizes << endl;
    
    file.close();
    file_sizes.close();
}


// ************************************************
//
//       END of output functions
//
//*************************************************


int main () {
    
    time_t time_beginning = time (NULL);
    if (type_log != 'n') {
            file_log.open (ofile_name_log);
        }
    
    // Generating the symmetry group
    ifstream file_group (ifile_name_group, ios::in);
    if ( generate_group (file_group, number_of_vertices, group_order, group_elements) ) {
        cout << "Group of order " << group_order << " generated" << endl;
        if (type_log != 'n') {
            file_log << "Group of order " << group_order << " generated" << endl;
        }
    } else {
        cout << "INCORRECT INITIAL DATA : Symmetry group" << endl;
        file_group.close();
        file_log.close();
        return 0;
    }
    file_group.close();
    
    // Reading dimension and lower bound for the number of maximal simplices
    
    ifstream file_dimnum (ifile_name_dimnum, ios::in);
    file_dimnum >> number_of_vertices_in_simplex;
    ++ number_of_vertices_in_simplex;     // add 1, since file contains dimension of max simplex
    file_dimnum >> min_number_of_maximal_simplices;
    file_dimnum.close();
    
    if (number_of_vertices_in_simplex <= 1 || number_of_vertices_in_simplex >= number_of_vertices
        || min_number_of_maximal_simplices < 0) {
        cout << "INCORRECT INITIAL DATA : File dimnum.dat" << endl;
        file_log.close();
        return 0;
    }
    
    // Reading initial set of simplices
    ifstream file_reqsimp;
    file_reqsimp.open (ifile_name_reqsimp, ios::in);
    if (!file_reqsimp.fail()) {
        if ( !read_triang(file_reqsimp, number_of_vertices, initial_simp) ) {
            cout << "INCORRECT INITIAL DATA : Required simplices" << endl;
            file_reqsimp.close();
            file_log.close();
            return 0;
        }
        cout << initial_simp.size() << " required simplices read" << endl;
        if (type_log != 'n') {
            file_log << initial_simp.size() << " required simplices read" << endl;
        }
        file_reqsimp.close();
    } else {
        cout << "No required simplices read" << endl;
        if (type_log != 'n') {
            file_log << "No required simplices read" << endl;
        }
    }
    initial_simp = minimize_simplices (initial_simp);


    ofstream file (ofile_name_wo_sizes, ios::out); file.close();    // clearing the files
    ofstream file_sizes (ofile_name_with_sizes, ios::out); file_sizes.close();  // for results
    
    generate_orbits_and_adjacency_groups();
    selection();
    
    time_t time_end = time (NULL);
    
    cout << endl;
    cout << "Number of triangulations found: " << number_of_triangulations << endl;
    cout << "Maximal level achieved: " << (int) maximal_level << endl;
    if (type_log != 'n') {
        file_log << endl;
        file_log << "Number of triangulations found: " << number_of_triangulations << endl;
        file_log << "Maximal level achieved: " << (int) maximal_level << endl;
    }

    
    double running_time = difftime (time_end, time_beginning);
    
    int int_time = (int) running_time;
    int hours = int_time / 3600;
    int minutes = (int_time % 3600) / 60;
    int seconds = int_time % 60;
    
    cout << "Running time: ";
    if (type_log != 'n') { file_log << "Running time: ";}
    if (int_time >= 3600) {
        cout << hours << " h " << minutes << " min " << seconds << " sec" << endl;
        if (type_log != 'n') {
            file_log << hours << " h " << minutes << " min " << seconds << " sec" << endl;
        }
    } else if (int_time >= 60) {
        cout << minutes << " min " << seconds << " sec" << endl;
        if (type_log != 'n') {
            file_log << minutes << " min " << seconds << " sec" << endl;
        }
    } else {
        cout << seconds << " sec" << endl;
        if (type_log != 'n') {
            file_log << seconds << " sec" << endl;
        }
    }
    
    file_log.close();
    return 0;
}


